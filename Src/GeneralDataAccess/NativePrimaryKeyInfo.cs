#region 版权及版本变化申明
/*-----------------------------------------------------------------------------------------------------------
// Copyright (C) 2012 广州优亿信息科技有限公司
// 版权所有
// 
//
// 文件名：NativePrimaryKeyInfo.cs
// 文件功能描述：存储原生主键的相关信息。
//
//
// 创建标识：宋冰（billsoff@gmail.com） 20110726
//
// 修改标识：
// 修改描述：
//
// --------------------------------------------------------------------------------------------------------*/
#endregion 版权及版本变化申明

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace Useease.GeneralDataAccess
{
    /// <summary>
    /// 存储原生主键的相关信息。
    /// </summary>
    internal abstract class NativePrimaryKeyInfo
    {
        #region 私有字段

        private CompositeBuilderStrategy m_builderStrategy;

        #endregion

        #region 构造函数

        /// <summary>
        /// 默认构造函数。
        /// </summary>
        protected NativePrimaryKeyInfo()
        {
        }

        #endregion

        #region 公共属性

        /// <summary>
        /// 获取生成策略。
        /// </summary>
        public CompositeBuilderStrategy BuilderStrategy
        {
            get
            {
                if ((m_builderStrategy == null) && IsNative)
                {
                    m_builderStrategy = CreateBuilderStrategy();
                }

                return m_builderStrategy;
            }
        }

        #endregion

        #region 公共方法

        /// <summary>
        /// 为候选键生成值。
        /// </summary>
        /// <param name="entity">实体。</param>
        public void GenerateCandidateKeyValue(Object entity)
        {
            GenerateCandidateKeyValues(new Object[] { entity });
        }

        /// <summary>
        /// 为候选键生成值。
        /// </summary>
        /// <param name="entities">实体列表。</param>
        public void GenerateCandidateKeyValues(IList<Object> entities)
        {
            EntityPropertyDefinition autoGenerateedCandidateKey = GetAutoGeneratedCandidateKey();

            #region 前置断言

            Debug.Assert(
                    (autoGenerateedCandidateKey == null)
                    || ((autoGenerateedCandidateKey.Type == typeof(String)) && (CandidateKeys.Length == 1)),
                    String.Format("如果属性标记为候选键且自动生成，则其类型应为 String，且候选键不能多于一个。")
                );

            #endregion

            if (autoGenerateedCandidateKey != null)
            {
                #region 前置条件

                Debug.Assert(
                        (new List<Object>(entities)).TrueForAll(
                                delegate(Object e)
                                {
                                    return Definition.Type.IsAssignableFrom(e.GetType());
                                }
                            ),
                        "所给的实体列表中包含有与当前类型不兼容的类型。"
                    );

                #endregion

                foreach (Object e in entities)
                {
                    autoGenerateedCandidateKey.PropertyInfo.SetValue(e, Guid.NewGuid().ToString(), null);
                }
            }
        }

        /// <summary>
        /// 获取自动生成候选键属性定义。
        /// </summary>
        public EntityPropertyDefinition GetAutoGeneratedCandidateKey()
        {
            if (IsNative && (CandidateKeys.Length == 1) && CandidateKeys[0].AutoGenerateOnNew)
            {
                return CandidateKeys[0];
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// 设置自增长（标识）主键的值。
        /// </summary>
        /// <param name="entity">实体。</param>
        /// <param name="value">主键值。</param>
        public void SetAutoIncrementPrimaryKeyValue(Object entity, Object value)
        {
            NativePrimaryKey.PropertyInfo.SetValue(
                    entity,
                    Convert.ChangeType(value, NativePrimaryKey.PropertyInfo.PropertyType),
                    null
                );
        }

        /// <summary>
        /// 加载主键值。
        /// </summary>
        /// <param name="entity">实体。</param>
        /// <param name="databaseSession">数据库会话引擎。</param>
        public void LoadPrimaryKeyValue(Object entity, IDatabaseSession databaseSession)
        {
            LoadPrimaryKeyValues(new Object[] { entity }, databaseSession);
        }

        /// <summary>
        /// 加载主键值。
        /// </summary>
        /// <param name="entities">实体列表。</param>
        /// <param name="databaseSession">数据库会话引擎。</param>
        public void LoadPrimaryKeyValues(IList<Object> entities, IDatabaseSession databaseSession)
        {
            if (IsNative)
            {
                #region 前置条件

                Debug.Assert(
                        (new List<Object>(entities)).TrueForAll(
                                delegate(Object e)
                                {
                                    return Definition.Type.IsAssignableFrom(e.GetType());
                                }
                            ),
                        "所给的实体列表中包含有与当前类型不兼容的类型。"
                    );

                #endregion

                // 加载包含主键和候补键的实体集合
                Filter filter = ComposeFilter(entities);
                Object[] keys = databaseSession.Load(Definition.Type, BuilderStrategy, filter);

                foreach (Object e in entities)
                {
                    Object k = Array.Find(
                            keys,
                            delegate(Object item)
                            {
                                foreach (EntityPropertyDefinition propertyDef in CandidateKeys)
                                {
                                    Object entityValue = propertyDef.PropertyInfo.GetValue(e, null);
                                    Object keyValue = propertyDef.PropertyInfo.GetValue(item, null);

                                    Debug.Assert(entityValue != null, "实体的候补键的值不能为空。");
                                    Debug.Assert(keyValue != null, "键实体的候补键的值不能为空。");

                                    if (!entityValue.Equals(keyValue))
                                    {
                                        return false;
                                    }
                                }

                                return true;
                            }
                        );

                    if (k != null)
                    {
                        NativePrimaryKey.PropertyInfo.SetValue(
                                e,
                                NativePrimaryKey.PropertyInfo.GetValue(k, null),
                                null
                            );
                    }
                    else
                    {
                        Debug.Fail("加载实体的原生主键失败。");
                    }
                }
            }
        }

        #endregion

        #region 抽象成员

        /// <summary>
        /// 获取实体定义。
        /// </summary>
        public abstract EntityDefinition Definition { get; }

        /// <summary>
        /// 获取一个值，该值指示主键是否为原生的。
        /// </summary>
        public abstract Boolean IsNative { get; }

        /// <summary>
        /// 获取一个值，该值指示主键是否为自增长（标识）字段。
        /// </summary>
        public abstract Boolean AutoIncrement { get; }

        /// <summary>
        /// 获取用于获取自增长（标识）字段值的 SQL 指令。
        /// </summary>
        public abstract String RetrieveIdentifierStatement { get; }

        /// <summary>
        /// 获取原生主键属性定义。
        /// </summary>
        public abstract EntityPropertyDefinition NativePrimaryKey { get; }

        /// <summary>
        /// 获取候选键属性定义集合。
        /// </summary>
        public abstract EntityPropertyDefinition[] CandidateKeys { get; }

        #endregion

        #region 辅助方法

        /// <summary>
        /// 创建过滤器。
        /// </summary>
        /// <param name="entities">实体列表。</param>
        /// <returns>创建好的过滤器。</returns>
        private Filter ComposeFilter(IList<Object> entities)
        {
            if (entities.Count == 1)
            {
                return ComposeFilter(entities[0]);
            }
            else if ((CandidateKeys.Length == 1) && CandidateKeys[0].IsPrimitive)
            {
                Object[] propertyValues = new Object[entities.Count];

                for (Int32 i = 0; i < propertyValues.Length; i++)
                {
                    propertyValues[i] = CandidateKeys[0].PropertyInfo.GetValue(entities[i], null);
                }

                return Filter.Create(CandidateKeys[0].Name, Is.InValues(propertyValues));
            }
            else
            {
                Filter[] filters = new Filter[entities.Count];

                for (Int32 i = 0; i < filters.Length; i++)
                {
                    filters[i] = ComposeFilter(entities[i]);
                }

                Filter composite = Filter.Combine(LogicOperator.Or, filters);

                return composite;
            }
        }

        /// <summary>
        /// 创建过滤器。
        /// </summary>
        /// <param name="entity">实体。</param>
        /// <returns>创建好的过滤器。</returns>
        private Filter ComposeFilter(Object entity)
        {
            if (CandidateKeys.Length == 1)
            {
                Object propertyValue = CandidateKeys[0].PropertyInfo.GetValue(entity, null);

                return Filter.Create(CandidateKeys[0].Name, Is.EqualTo(propertyValue));
            }
            else
            {
                Filter[] filters = Array.ConvertAll<EntityPropertyDefinition, Filter>(
                        CandidateKeys,
                        delegate(EntityPropertyDefinition propertyDef)
                        {
                            Object propertyValue = propertyDef.PropertyInfo.GetValue(entity, null);

                            return Filter.Create(propertyDef.Name, Is.EqualTo(propertyValue));
                        }
                    );

                Filter composite = Filter.Combine(LogicOperator.And, filters);

                return composite;
            }
        }

        /// <summary>
        /// 创建加载策略，选择主键和候选键。
        /// </summary>
        /// <returns>创建好的加载策略。</returns>
        private CompositeBuilderStrategy CreateBuilderStrategy()
        {
            return Select.Property(Definition.Type, new String[] { NativePrimaryKey.Name })
                    .Properties(
                            Array.ConvertAll<EntityPropertyDefinition, IPropertyChain>(
                                    CandidateKeys,
                                    delegate(EntityPropertyDefinition propertyDef)
                                    {
                                        return new PropertyChain(Definition.Type, new String[] { propertyDef.Name });
                                    }
                                )
                        );
        }

        #endregion
    }
}